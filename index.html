<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Face Extractor — Modern (Glass)</title>

  <!-- face-api.js from CDN (script must be available; models are loaded from ./ ) -->
  <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

  <style>
    /* Modern glass UI */
    :root{
      --bg: #0f1724;
      --card: rgba(255,255,255,0.06);
      --glass: rgba(255,255,255,0.04);
      --accent: linear-gradient(90deg,#ff5f6d,#ffc371);
      --muted: rgba(255,255,255,0.6);
      --glass-border: rgba(255,255,255,0.08);
    }
    html,body{height:100%; margin:0; font-family: Inter, "Segoe UI", Roboto, Arial; background: radial-gradient(1200px 600px at 10% 10%, rgba(82,63,255,0.08), transparent), var(--bg); color:#e6eef8; -webkit-font-smoothing:antialiased;}
    .container{max-width:1100px; margin:28px auto; padding:22px; border-radius:14px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); box-shadow: 0 8px 30px rgba(2,6,23,0.6); border:1px solid var(--glass-border);}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    h1{margin:0; font-size:20px; letter-spacing:0.2px;}
    .subtitle{color:var(--muted); font-size:13px;}
    .controls{display:flex; gap:10px; align-items:center;}
    .btn{padding:10px 14px; border-radius:10px; border:none; cursor:pointer; font-weight:600; background:var(--accent); color:#071022; box-shadow:0 6px 18px rgba(0,0,0,0.45);}
    .btn.secondary{background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04);}
    .status{margin-top:16px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    .status .pill{padding:8px 12px; background:var(--glass); border-radius:999px; border:1px solid rgba(255,255,255,0.03); color:var(--muted); font-size:13px;}
    .grid{display:grid; grid-template-columns: 1fr 420px; gap:18px; margin-top:18px;}
    /* left: main image area */
    .main-area{padding:14px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); min-height:360px; display:flex; flex-direction:column; align-items:center; justify-content:flex-start;}
    #previewWrap{position:relative; width:100%; display:flex; align-items:center; justify-content:center; overflow:hidden;}
    #preview{max-width:100%; height:auto; border-radius:8px; box-shadow: 0 8px 30px rgba(2,6,23,0.6); display:block;}
    .overlay-canvas{position:absolute; left:0; top:0; pointer-events:none;}
    /* right: side panel for crops + logs */
    .side-panel{padding:14px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); min-height:360px; display:flex; flex-direction:column; gap:12px;}
    .panel-title{font-weight:700; font-size:14px;}
    .crops{display:grid; grid-template-columns: repeat(2, 1fr); gap:10px; overflow:auto; max-height:360px; padding-right:6px;}
    .crop-card{background:var(--card); border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:8px; align-items:center; border:1px solid rgba(255,255,255,0.02);}
    .crop-card img{width:100%; height:120px; object-fit:cover; border-radius:6px;}
    .crop-actions{display:flex; gap:8px; width:100%; justify-content:space-between; align-items:center;}
    .small-btn{padding:6px 8px; border-radius:8px; font-weight:600; font-size:13px; border:none; cursor:pointer;}
    .download-btn{background:linear-gradient(90deg,#5ef3b3,#2bd4ff); color:#042a2b;}
    .zoom-btn{background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.03);}
    .log-panel{background:rgba(5,8,15,0.4); border-radius:10px; padding:8px; color:var(--muted); font-size:13px; max-height:120px; overflow:auto;}
    .meta{display:flex; gap:8px; align-items:center; color:var(--muted); font-size:13px;}
    /* spinner */
    .spinner{width:18px; height:18px; border-radius:50%; border:3px solid rgba(255,255,255,0.08); border-top-color:white; animation: spin 1s linear infinite; display:inline-block;}
    @keyframes spin{to{transform:rotate(360deg)}}
    footer{margin-top:18px; color:var(--muted); font-size:13px; text-align:center;}
    @media (max-width:980px){
      .grid{grid-template-columns: 1fr; }
      .crops{grid-template-columns: repeat(3, 1fr);}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Face Extractor</h1>
        <div class="subtitle">Modern glass UI · All models loaded from <code>./</code> (repo root: Faces/)</div>
      </div>

      <div class="controls">
        <label class="btn" for="fileInput" title="Upload group photo">Upload Photo</label>
        <input id="fileInput" type="file" accept="image/*" style="display:none" />
        <button id="clearBtn" class="btn secondary">Clear</button>
      </div>
    </header>

    <div class="status" style="margin-top:12px;">
      <div id="statusPill" class="pill">Initializing…</div>
      <div id="modelPill" class="pill">Models: not loaded</div>
      <div id="detPill" class="pill">Faces: -</div>
      <div id="timePill" class="pill">Time: -</div>
    </div>

    <div class="grid">
      <div class="main-area">
        <div id="previewWrap">
          <img id="preview" alt="uploaded preview" style="display:none" />
          <canvas id="overlay" class="overlay-canvas" style="display:none"></canvas>
        </div>

        <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
          <button id="detectBtn" class="btn" disabled>Detect Faces</button>
          <button id="downloadAllBtn" class="btn secondary" disabled>Download All Crops</button>
          <div style="flex:1"></div>
          <div id="miniSpinner" style="display:none"><span class="spinner"></span></div>
        </div>
      </div>

      <aside class="side-panel">
        <div>
          <div class="panel-title">Cropped Faces</div>
          <div style="color:var(--muted); font-size:13px; margin-top:6px;">Each crop can be downloaded or zoomed.</div>
        </div>

        <div id="crops" class="crops"></div>

        <div>
          <div class="panel-title" style="margin-top:8px">Logs</div>
          <div id="logs" class="log-panel"></div>
        </div>
      </aside>
    </div>

    <footer>
      Built for GitHub Pages — models must be in the <code>Faces/</code> folder next to this file. Use <code>./</code> load paths.
    </footer>
  </div>

<script>
/*
  Full-featured index.html:
  - Loads face-api.js from CDN
  - Loads models from './' (same folder as index.html)
  - Modern glass UI: spinner, status, overlays
  - Detect button (prevents accidental repeated actions)
  - Draws bounding boxes on overlay
  - Crops faces, shows grid with download and zoom
  - Download all button
  - Verbose logs panel for debugging
  - Mobile-friendly image loading
*/

(async function () {
  // UI references
  const fileInput = document.getElementById('fileInput');
  const preview = document.getElementById('preview');
  const overlay = document.getElementById('overlay');
  const detectBtn = document.getElementById('detectBtn');
  const clearBtn = document.getElementById('clearBtn');
  const cropsEl = document.getElementById('crops');
  const logsEl = document.getElementById('logs');
  const statusPill = document.getElementById('statusPill');
  const modelPill = document.getElementById('modelPill');
  const detPill = document.getElementById('detPill');
  const timePill = document.getElementById('timePill');
  const miniSpinner = document.getElementById('miniSpinner');
  const downloadAllBtn = document.getElementById('downloadAllBtn');

  // Internal state
  let currentImageFile = null;
  let currentDetections = [];
  let busy = false;

  function log(...args){
    const t = new Date().toLocaleTimeString();
    const line = document.createElement('div');
    line.textContent = `[${t}] ${args.join(' ')}`;
    logsEl.prepend(line);
    console.log(...args);
  }

  function setStatus(text){
    statusPill.textContent = text;
  }
  function setModelStatus(text){
    modelPill.textContent = text;
  }
  function setDetStatus(text){
    detPill.textContent = text;
  }
  function setTimeStatus(text){
    timePill.textContent = text;
  }

  function showSpinner(on){
    miniSpinner.style.display = on ? 'block' : 'none';
  }

  // MODEL LOADING
  async function loadModels(){
    try {
      setStatus('Loading models from ./ (this could take a few seconds)…');
      setModelStatus('loading…');
      // Load the primary models you need. All files are expected in the same folder as index.html
      await faceapi.nets.ssdMobilenetv1.loadFromUri('./');         // detection
      await faceapi.nets.faceLandmark68Net.loadFromUri('./');      // landmarks
      // optional: recognition / expressions / ageGender if present
      try { await faceapi.nets.faceRecognitionNet.loadFromUri('./'); } catch(e){}
      try { await faceapi.nets.faceExpressionNet.loadFromUri('./'); } catch(e){}
      try { await faceapi.nets.ageGenderNet.loadFromUri('./'); } catch(e){}
      setModelStatus('loaded ✔');
      setStatus('Models loaded. Choose a photo.');
      log('Models loaded from: ./');
    } catch (err) {
      setModelStatus('failed ❌');
      setStatus('Failed to load models — check filenames and console.');
      log('Model load error:', err.message || err);
      throw err;
    }
  }

  // Mobile-friendly image loader that returns an HTMLImageElement
  function loadImageFromFile(file){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = (e) => reject(e);
      img.src = URL.createObjectURL(file);
      // don't set crossOrigin for object URLs
    });
  }

  // Resize overlay to preview size and return context
  function syncOverlay(){
    overlay.width = preview.clientWidth;
    overlay.height = preview.clientHeight;
    overlay.style.left = preview.offsetLeft + 'px';
    overlay.style.top = preview.offsetTop + 'px';
  }

  // Draw detection boxes and landmarks on overlay
  function drawDetections(detections, originalImage){
    const ctx = overlay.getContext('2d');
    // clear and size
    overlay.width = preview.clientWidth;
    overlay.height = preview.clientHeight;
    ctx.clearRect(0,0,overlay.width,overlay.height);

    // scaling factors: original image -> displayed preview
    const scaleX = preview.clientWidth / originalImage.width;
    const scaleY = preview.clientHeight / originalImage.height;

    ctx.lineWidth = 2.5;
    ctx.strokeStyle = '#00ffd0';
    ctx.fillStyle = 'rgba(0,255,208,0.08)';

    detections.forEach(det => {
      const box = det.detection.box;
      const x = box.x * scaleX;
      const y = box.y * scaleY;
      const w = box.width * scaleX;
      const h = box.height * scaleY;
      // rounded rect
      roundRect(ctx, x, y, w, h, 8);
      ctx.fillRect(x, y, w, h);
      // label - confidence
      const conf = (det.detection.score || 0).toFixed(2);
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(x, y - 20, 70, 18);
      ctx.fillStyle = '#fff';
      ctx.font = '12px Inter, Arial';
      ctx.fillText(`conf:${conf}`, x + 6, y - 6);
      ctx.fillStyle = 'rgba(0,255,208,0.08)';

      // optional: draw landmarks points
      if (det.landmarks && det.landmarks.positions) {
        ctx.fillStyle = '#ffd34d';
        det.landmarks.positions.forEach(pt => {
          ctx.beginPath();
          ctx.arc(pt.x * scaleX, pt.y * scaleY, 1.6, 0, Math.PI*2);
          ctx.fill();
        });
      }
    });
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.stroke();
  }

  // Crop face from original image using box (box in original image pixel coords)
  function cropFaceToDataURL(imgElement, box, targetSize) {
    // maintain aspect ratio, but create a square-ish result if targetSize provided
    const tmp = document.createElement('canvas');
    const w = Math.round(box.width);
    const h = Math.round(box.height);
    const canvasW = targetSize ? targetSize : w;
    const canvasH = targetSize ? targetSize : h;
    tmp.width = canvasW;
    tmp.height = canvasH;
    const ctx = tmp.getContext('2d');

    // draw using source image, map box to canvas (fit)
    ctx.drawImage(imgElement, box.x, box.y, box.width, box.height, 0, 0, canvasW, canvasH);
    return tmp.toDataURL('image/png');
  }

  // Build crop card UI and attach actions
  function addCropCard(dataUrl, index){
    const card = document.createElement('div');
    card.className = 'crop-card';

    const img = document.createElement('img');
    img.src = dataUrl;
    img.alt = `face-${index}`;

    const actions = document.createElement('div');
    actions.className = 'crop-actions';

    const dl = document.createElement('button');
    dl.className = 'small-btn download-btn';
    dl.textContent = 'Download';
    dl.onclick = () => {
      // trigger download
      const a = document.createElement('a');
      a.href = dataUrl;
      a.download = `face_${index+1}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    };

    const zoom = document.createElement('button');
    zoom.className = 'small-btn zoom-btn';
    zoom.textContent = 'Zoom';
    zoom.onclick = () => {
      // open in new tab for zoom
      const w = window.open();
      w.document.write(`<title>Face ${index+1}</title><img src="${dataUrl}" style="max-width:100%"/>`);
    };

    actions.appendChild(dl);
    actions.appendChild(zoom);

    card.appendChild(img);
    card.appendChild(actions);

    cropsEl.appendChild(card);
  }

  // Download all crops as a zip-like single archive is heavy; instead create a multi-download helper
  function downloadAllCrops(){
    const cropImgs = Array.from(cropsEl.querySelectorAll('img'));
    cropImgs.forEach((im, idx) => {
      const a = document.createElement('a');
      a.href = im.src;
      a.download = `face_${idx+1}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    });
  }

  // CLEAR UI
  function clearAll(){
    preview.style.display = 'none';
    preview.src = '';
    overlay.style.display = 'none';
    cropsEl.innerHTML = '';
    logsEl.innerHTML = '';
    setDetStatus('-');
    setTimeStatus('-');
    detectBtn.disabled = true;
    downloadAllBtn.disabled = true;
    currentImageFile = null;
    currentDetections = [];
  }

  // Initialize models
  try {
    await loadModels();
  } catch(e){
    // model load failed; keep UI but disable detection
    detectBtn.disabled = true;
    log('Fatal: models failed to load. Please verify filenames in repo root.');
  }

  // Event handlers
  fileInput.addEventListener('change', async (ev) => {
    if (busy) {
      log('Busy; wait for current processing to finish.');
      fileInput.value = '';
      return;
    }
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;
    busy = true;
    setStatus('Preparing image…');
    showSpinner(true);

    try {
      currentImageFile = file;
      // load image
      const img = await loadImageFromFile(file);
      // place into preview and show
      preview.src = img.src;
      preview.style.display = 'block';
      overlay.style.display = 'block';
      // give browser time to layout
      await new Promise(r=>setTimeout(r,60));
      syncOverlay();

      setStatus('Image loaded. Ready to detect.');
      detectBtn.disabled = false;
      log(`Image loaded: ${file.name} (${img.width}×${img.height})`);
    } catch (err) {
      log('Image load error:', err);
      setStatus('Failed to load image');
    } finally {
      busy = false;
      showSpinner(false);
      // clear input value so same file can be reselected if needed
      fileInput.value = '';
    }
  });

  // Detect button explicit control
  detectBtn.addEventListener('click', async () => {
    if (!preview.src) { setStatus('No image. Upload first.'); return; }
    if (busy) { log('Already processing'); return; }

    busy = true;
    setStatus('Detecting faces…');
    showSpinner(true);
    detectBtn.disabled = true;
    clearBtn.disabled = true;
    downloadAllBtn.disabled = true;
    cropsEl.innerHTML = '';
    logsEl.innerHTML = '';

    try {
      const start = performance.now();
      // convert preview src to an HTMLImageElement in memory (face-api works with Image or canvas)
      const img = await loadImageFromFile(dataURLtoFile(preview.src, 'preview.png'));
      // perform detection using SSD Mobilenet v1 (good balance)
      const detections = await faceapi.detectAllFaces(img, new faceapi.SsdMobilenetv1Options({minConfidence:0.45})).withFaceLandmarks();
      const end = performance.now();
      const ms = Math.round(end - start);
      setTimeStatus(`${ms} ms`);
      setDetStatus(`${detections.length} faces`);
      log(`Detection completed: ${detections.length} faces in ${ms} ms`);
      currentDetections = detections;

      if (detections.length === 0) {
        setStatus('No faces detected. Try a clearer image or crop closer.');
        overlay.getContext('2d').clearRect(0,0,overlay.width,overlay.height);
        busy = false;
        detectBtn.disabled = false;
        clearBtn.disabled = false;
        return;
      }

      // draw bounding boxes
      drawDetections(detections, img);
      setStatus('Rendering crops…');

      // generate crops and UI
      detections.forEach((det, idx) => {
        // det.detection.box is in original image pixel coords
        const box = det.detection.box;
        const dataUrl = cropFaceToDataURL(img, box, 260); // square-ish crop
        addCropCard(dataUrl, idx);
      });

      downloadAllBtn.disabled = false;
      setStatus('Done — crops ready.');
    } catch (err) {
      console.error('Detection error:', err);
      setStatus('Error during detection. See logs.');
      log('Detection error:', err.message || err);
    } finally {
      busy = false;
      showSpinner(false);
      detectBtn.disabled = false;
      clearBtn.disabled = false;
    }
  });

  clearBtn.addEventListener('click', clearAll);
  downloadAllBtn.addEventListener('click', downloadAllCrops);

  // helper: dataURL -> File (so we can use loadImageFromFile uniformly)
  function dataURLtoFile(dataurl, filename) {
    const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
      bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
    for (let i = 0; i < n; i++) u8arr[i] = bstr.charCodeAt(i);
    return new File([u8arr], filename, {type:mime});
  }

  // final note
  log('UI ready. Models should be loaded and ready to use.');
  setStatus('Ready — upload a photo to start.');
})();
</script>
</body>
</html>
